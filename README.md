# Dune Awakening - Desert Planner

## Project Overview

This web application serves as a "Desert Planner" for the game *Dune Awakening*. It allows users to select various craftable items, structures, and equipment they might want to take or build for expeditions into the deep desert of Arrakis. Based on these selections, the tool calculates and displays the total raw materials required and provides a summary of power generation and consumption.

The primary goal is to help players efficiently plan their resource gathering and crafting efforts before embarking on dangerous journeys or establishing outposts. The visual design and color scheme are inspired by the official Dune Awakening website to provide a thematic user experience.

## Features

*   **Dynamic Item Selection**: Users can browse a comprehensive list of in-game items (sourced from provided data and manual additions) and select desired quantities using checkboxes. The list is sorted alphabetically for ease of use.
*   **Material Calculation**: Automatically calculates the sum of all raw materials needed to craft the selected items. This includes materials like Steel Ingots, Silicon Blocks, Duraluminium, Spice Melange, etc.
*   **Power Management Summary**:
    *   Calculates total power generated by selected items (e.g., Wind Turbines, Spice Generators).
    *   Calculates total power consumed by selected items (e.g., Refineries, Fabricators).
    *   Displays the net power balance, helping players ensure they have sufficient power for their setup. The net power is color-coded for immediate visual feedback.
*   **Thematic UI**: Styled with a dark theme and color accents (sandy golds, oranges) reminiscent of the Dune universe and the official game website.
*   **Client-Side Operation**: Runs entirely in the user's web browser using HTML, CSS, and JavaScript. No server-side backend is required for its core functionality.
*   **Data Source**: Item data, including material costs and power attributes, is primarily sourced from a CSV-like string embedded within the JavaScript. This data is supplemented by manually added items as per the initial requirements. Duplicate items in the source data (like "Pentashield Surface Vertical") are handled by only including one instance.

## File Structure

The project consists of the following core files:

*   `index.html`: The main HTML file that provides the structural backbone for the web application. It defines the layout, including sections for item selection, material summary, and power overview.
*   `style.css`: The Cascading Style Sheet (CSS) file responsible for all visual aspects of the application. This includes layout, colors, fonts, and spacing, aiming to evoke the aesthetic of Dune Awakening.
*   `script.js`: The JavaScript file that contains all the application's interactive logic:
    *   Parsing the embedded CSV item data and merging it with manually defined items.
    *   Dynamically populating the item selection list in the HTML.
    *   Handling user interactions, specifically checkbox selections.
    *   Performing real-time calculations for total materials and power statistics.
    *   Updating the summary display dynamically as users make selections.
*   `README.md`: This file, providing a comprehensive description of the project, its features, how it works, and deployment instructions.

## How It Works

The application operates based on a straightforward client-side workflow:

1.  **Page Initialization (`DOMContentLoaded`)**:
    *   Once the HTML document is fully loaded and parsed, the `script.js` begins execution.
    *   **Data Preparation**: An array of item data is constructed. This involves:
        *   Parsing a multi-line CSV string that is hardcoded into the script. This string contains the list of items, their material costs, and power attributes.
        *   Defining additional items manually as JavaScript objects (e.g., "Medium Water Cistern," "Large Water Cistern") to supplement the CSV data.
        *   Merging these two sources into a single `allItems` array.
        *   Each item in this array is an object typically structured as:
            ```javascript
            {
              name: "Item Name",
              materials: { "Material1": quantity, "Material2": quantity, ... },
              powerGenerated: value,
              powerCost: value
            }
            ```
        *   The `allItems` array is then sorted alphabetically by item name to improve user experience.

2.  **Populating the Item List (`populateItems()` function)**:
    *   This function iterates through the `allItems` array.
    *   For each item, it dynamically creates the necessary HTML elements:
        *   A `div` with class `item-entry` to contain the checkbox and label.
        *   An `<input type="checkbox">` element. Each checkbox is assigned a unique ID and its `value` attribute is set to the item's name.
        *   A `<label>` associated with the checkbox, displaying the item's name.
    *   An event listener is attached to each checkbox. This listener triggers the `calculateTotals()` function whenever the checkbox's state (checked/unchecked) changes.
    *   These dynamically created elements are appended to the `#item-list` div in `index.html`.

3.  **User Interaction and Calculation (`calculateTotals()` function)**:
    *   This function is called whenever an item checkbox is toggled.
    *   It first identifies all currently selected (checked) items by querying the DOM for checked checkboxes within the `#item-list`.
    *   It initializes variables to store `totalMaterials` (as an object), `totalPowerGenerated`, and `totalPowerConsumed`.
    *   It then iterates through each selected item:
        *   For materials, it iterates through the item's `materials` object. Each material's quantity is added to the corresponding entry in the `totalMaterials` object.
        *   The item's `powerGenerated` and `powerCost` values are added to the respective total power accumulators.

4.  **Displaying the Summarized Results (`displayTotals()` function)**:
    *   This function receives the calculated `totalMaterials`, `totalPowerGenerated`, and `totalPowerConsumed` as arguments.
    *   **Materials Update**: It clears any previous entries in the `#materials-list` unordered list. Then, it iterates through the `totalMaterials` object. For each material with a quantity greater than zero, it creates an `<li>` element displaying the material name and its total quantity, and appends it to the list. If no materials are required, a placeholder message is shown.
    *   **Power Update**: It updates the text content of the appropriate `<span>` elements within the `#power-summary` section to display the new totals for power generated, power consumed, and the net power (calculated as `totalPowerGenerated - totalPowerConsumed`).
    *   The color of the net power display is dynamically changed: green if the net power is zero or positive, and red if it's negative.

5.  **Initial State**:
    *   Upon initial page load, `populateItems()` is called to display all available items, and `calculateTotals()` is called to ensure the summary sections display initial zero/empty states correctly.

## Deployment Guide

This web application is a client-side project, meaning it consists only of static files (HTML, CSS, JavaScript) and does not require a complex backend or database. It can be deployed easily using various methods:

**1. Simple Local File Access (for personal use/testing):**

*   **How**: Simply open the `index.html` file directly in your web browser.
*   **Steps**:
    1.  Ensure all three files (`index.html`, `style.css`, `script.js`) are in the same directory.
    2.  Navigate to this directory in your file explorer.
    3.  Double-click `index.html`, or right-click and choose "Open with" your preferred web browser.
*   **Limitations**: This method is fine for local use but not for sharing with others over the internet. Some browser features or security policies might behave differently with `file:///` URLs compared to `http://` or `https://`.

**2. Using a Simple HTTP Server (for local development/testing):**

*   **How**: Use a lightweight local HTTP server to serve the files. This better simulates a real web server environment.
*   **Python's Built-in Server (Python 3)**:
    1.  Open your terminal or command prompt.
    2.  Navigate to the directory containing the project files: `cd path/to/your/project_directory`
    3.  Run the command: `python -m http.server`
    4.  Open your web browser and go to `http://localhost:8000` (or the port number shown in the terminal).
*   **Node.js `http-server` package**:
    1.  Ensure you have Node.js and npm installed.
    2.  Install `http-server` globally (if you haven't already): `npm install -g http-server`
    3.  Open your terminal or command prompt.
    4.  Navigate to the project directory: `cd path/to/your/project_directory`
    5.  Run the command: `http-server`
    6.  Open your browser and go to `http://localhost:8080` (or the address shown in the terminal).
*   **VS Code Live Server Extension**:
    1.  If you are using Visual Studio Code, install the "Live Server" extension from the Marketplace.
    2.  Open the project folder in VS Code.
    3.  Right-click on `index.html` in the explorer panel and select "Open with Live Server." This will automatically open the page in your browser and reload it on changes.

**3. Deploying to a Static Web Host (for sharing online):**

Numerous platforms offer free or paid hosting for static websites. These services are ideal for deploying this type of application.

*   **GitHub Pages**:
    1.  Ensure your project is a GitHub repository. If not, create one and push your files (`index.html`, `style.css`, `script.js`).
    2.  Go to your repository's page on GitHub.
    3.  Click on the "Settings" tab.
    4.  In the left sidebar, navigate to "Pages."
    5.  Under "Build and deployment," choose your source (typically "Deploy from a branch").
    6.  Select the branch you want to deploy (e.g., `main` or `master`). For the folder, usually select `/ (root)`.
    7.  Click "Save." GitHub Actions will build and deploy your site.
    8.  After a few minutes, your site will be available at a URL like `https://your-username.github.io/your-repository-name/`.
*   **Netlify**:
    1.  Sign up for a free Netlify account.
    2.  **Option A (Drag and Drop)**: Simply drag the folder containing your project files (`index.html`, `style.css`, `script.js`) onto the "Sites" page in your Netlify dashboard.
    3.  **Option B (Git Integration - Recommended)**:
        *   Click "Add new site" -> "Import an existing project."
        *   Connect to your Git provider (GitHub, GitLab, Bitbucket) and authorize Netlify.
        *   Select your repository.
        *   Deployment settings are usually auto-detected for simple static sites (no build command needed, publish directory is the base directory).
        *   Click "Deploy site." Netlify will build and deploy, providing a unique URL (e.g., `random-name.netlify.app`). You can customize this later.
*   **Vercel**:
    1.  Sign up for a Vercel account.
    2.  Click "Add New..." -> "Project."
    3.  Import your Git repository.
    4.  Vercel will typically auto-detect it as a static site. No special build settings are required.
    5.  Click "Deploy." Vercel will deploy your site and provide a URL.
*   **Cloudflare Pages**:
    1.  Sign up for a Cloudflare account.
    2.  Go to "Workers & Pages" -> "Create application" -> "Pages" -> "Connect to Git."
    3.  Select your repository and begin setup.
    4.  For "Build settings," choose "None" or leave build command empty, and set the output directory to the root if your files are there.
    5.  Deploy the site.
*   **Amazon S3 (with CloudFront - More Advanced)**:
    1.  Create an S3 bucket in AWS.
    2.  Upload your `index.html`, `style.css`, and `script.js` files.
    3.  Configure the S3 bucket for static website hosting (set `index.html` as the index document).
    4.  Optionally (but recommended for production), create an AWS CloudFront distribution that points to your S3 bucket. This provides HTTPS, caching, and global content delivery.
*   **Firebase Hosting**:
    1.  Create a Firebase project at the [Firebase Console](https://console.firebase.google.com/).
    2.  Install the Firebase CLI: `npm install -g firebase-tools`
    3.  Log in to Firebase: `firebase login`
    4.  In your project's root directory (where `index.html` is), run: `firebase init hosting`
        *   Select "Use an existing project" and choose your Firebase project.
        *   Specify your public directory (usually `.` or `/` if `index.html` is in the root).
        *   Configure as a single-page app: No (unless you intend to add routing later).
        *   Set up automatic builds and deploys with GitHub: Optionally.
    5.  Deploy your site: `firebase deploy`
    6.  Firebase will provide hosting URLs.

**General Tips for Static Hosting:**

*   **Root Directory**: Most platforms expect `index.html` to be at the root of what you deploy.
*   **No Build Step**: Since this project is plain HTML, CSS, and JS, no "build command" is necessary in the hosting platform's settings. The "publish directory" or "output directory" will just be the root of your project files.
*   **Custom Domains**: All these platforms support configuring a custom domain for your deployed site.

## Potential Future Enhancements

This planner serves as a functional base. Here are some ideas for future improvements:

*   **Item Quantities**: Allow users to input a specific number for each item they want to craft (e.g., 5 Windtraps), rather than just a binary selection.
*   **"Per Block" Calculator**: Implement the "Create block calculator" functionality for items like "Pentashield Surface Vertical," where costs might scale based on user input for the number of blocks or segments.
*   **External Data Source**: Load item data from an external JSON or CSV file fetched at runtime, making it easier to update game data without modifying the `script.js` directly.
*   **Filtering and Searching**: Add controls to filter the item list by category (e.g., power, structures, crafting stations) or search by item name, especially if the list grows extensive.
*   **Save/Load Loadouts**: Implement functionality for users to save their current selection of items (e.g., using browser `localStorage`) and load it back in a future session.
*   **Advanced Styling & UI/UX**:
    *   Further refine CSS to more closely match specific UI elements, icons, or textures from the Dune Awakening game as more visual references become available.
    *   Improve layout for smaller screens (responsive design).
*   **Framework Integration**: For more complex features or better state management, consider migrating the application to a modern JavaScript framework/library like React, Vue, Svelte, or Angular.
*   **Sharing Loadouts**: Allow users to generate a shareable link that pre-selects items based on the link's parameters.

This Dune Awakening Desert Planner provides a solid foundation for players to strategize their resource management and construction efforts on the harsh desert planet of Arrakis.
Remember, "The Spice Must Flow!" and careful planning is key to survival and dominance.
